
Begin Context.is_proxy (Slither line:1425)


End Context.is_proxy (Slither line:1428)


Begin Context.is_upgradeable_proxy (Slither line:1136)

Checking contract: Context 

End Context.is_upgradeable_proxy (Slither line:1407)


Begin Pausable.is_proxy (Slither line:1425)


End Pausable.is_proxy (Slither line:1428)


Begin Pausable.is_upgradeable_proxy (Slither line:1136)

Checking contract: Pausable 

End Pausable.is_upgradeable_proxy (Slither line:1407)


Begin Address.is_proxy (Slither line:1425)


End Address.is_proxy (Slither line:1428)


Begin Address.is_upgradeable_proxy (Slither line:1136)

Checking contract: Address 

End Address.is_upgradeable_proxy (Slither line:1407)


Begin IBEP20.is_proxy (Slither line:1425)


End IBEP20.is_proxy (Slither line:1428)


Begin IBEP20.is_upgradeable_proxy (Slither line:1136)

Checking contract: IBEP20 

End IBEP20.is_upgradeable_proxy (Slither line:1407)


Begin ITokenList.is_proxy (Slither line:1425)


End ITokenList.is_proxy (Slither line:1428)


Begin ITokenList.is_upgradeable_proxy (Slither line:1136)

Checking contract: ITokenList 

End ITokenList.is_upgradeable_proxy (Slither line:1407)


Begin IComptroller.is_proxy (Slither line:1425)


End IComptroller.is_proxy (Slither line:1428)


Begin IComptroller.is_upgradeable_proxy (Slither line:1136)

Checking contract: IComptroller 

End IComptroller.is_upgradeable_proxy (Slither line:1407)


Begin ILiquidator.is_proxy (Slither line:1425)


End ILiquidator.is_proxy (Slither line:1428)


Begin ILiquidator.is_upgradeable_proxy (Slither line:1136)

Checking contract: ILiquidator 

End ILiquidator.is_upgradeable_proxy (Slither line:1407)


Begin IDeposit.is_proxy (Slither line:1425)


End IDeposit.is_proxy (Slither line:1428)


Begin IDeposit.is_upgradeable_proxy (Slither line:1136)

Checking contract: IDeposit 

End IDeposit.is_upgradeable_proxy (Slither line:1407)


Begin IReserve.is_proxy (Slither line:1425)


End IReserve.is_proxy (Slither line:1428)


Begin IReserve.is_upgradeable_proxy (Slither line:1136)

Checking contract: IReserve 

End IReserve.is_upgradeable_proxy (Slither line:1407)


Begin ILoan.is_proxy (Slither line:1425)


End ILoan.is_proxy (Slither line:1428)


Begin ILoan.is_upgradeable_proxy (Slither line:1136)

Checking contract: ILoan 

End ILoan.is_upgradeable_proxy (Slither line:1407)


Begin ILoan1.is_proxy (Slither line:1425)


End ILoan1.is_proxy (Slither line:1428)


Begin ILoan1.is_upgradeable_proxy (Slither line:1136)

Checking contract: ILoan1 

End ILoan1.is_upgradeable_proxy (Slither line:1407)


Begin IOracleOpen.is_proxy (Slither line:1425)


End IOracleOpen.is_proxy (Slither line:1428)


Begin IOracleOpen.is_upgradeable_proxy (Slither line:1136)

Checking contract: IOracleOpen 

End IOracleOpen.is_upgradeable_proxy (Slither line:1407)


Begin IAccessRegistry.is_proxy (Slither line:1425)


End IAccessRegistry.is_proxy (Slither line:1428)


Begin IAccessRegistry.is_upgradeable_proxy (Slither line:1136)

Checking contract: IAccessRegistry 

End IAccessRegistry.is_upgradeable_proxy (Slither line:1407)


Begin AggregatorV3Interface.is_proxy (Slither line:1425)


End AggregatorV3Interface.is_proxy (Slither line:1428)


Begin AggregatorV3Interface.is_upgradeable_proxy (Slither line:1136)

Checking contract: AggregatorV3Interface 

End AggregatorV3Interface.is_upgradeable_proxy (Slither line:1407)


Begin IAugustusSwapper.is_proxy (Slither line:1425)


End IAugustusSwapper.is_proxy (Slither line:1428)


Begin IAugustusSwapper.is_upgradeable_proxy (Slither line:1136)

Checking contract: IAugustusSwapper 

End IAugustusSwapper.is_upgradeable_proxy (Slither line:1407)


Begin IPancakeRouter01.is_proxy (Slither line:1425)


End IPancakeRouter01.is_proxy (Slither line:1428)


Begin IPancakeRouter01.is_upgradeable_proxy (Slither line:1136)

Checking contract: IPancakeRouter01 

End IPancakeRouter01.is_upgradeable_proxy (Slither line:1407)


Begin IDiamondCut.is_proxy (Slither line:1425)


End IDiamondCut.is_proxy (Slither line:1428)


Begin IDiamondCut.is_upgradeable_proxy (Slither line:1136)

Checking contract: IDiamondCut 

End IDiamondCut.is_upgradeable_proxy (Slither line:1407)


Begin LibDiamond.is_proxy (Slither line:1425)


End LibDiamond.is_proxy (Slither line:1428)


Begin LibDiamond.is_upgradeable_proxy (Slither line:1136)

Checking contract: LibDiamond 

End LibDiamond.is_upgradeable_proxy (Slither line:1407)


Begin OpenDiamond.is_proxy (Slither line:1425)

NEW VARIABLE (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)

END_IF (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)

IF (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)

EXPRESSION (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)


Begin OpenDiamond.find_delegatecall_in_exp_node

Found Expression Node: calldatacopy(uint256,uint256,uint256)(0,0,calldatasize()()) (Slither line:2792)
Expression called: calldatacopy(uint256,uint256,uint256)
Type of call:  (Slither line:2807)
Args:
0
0
calldatasize()()

End OpenDiamond.find_delegatecall_in_exp_node (Slither line:2848)

INLINE ASM (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)


Found Assembly Node (Slither line:1447)


Begin OpenDiamond.find_delegatecall_in_asm (Slither line:1541)


End OpenDiamond.find_delegatecall_in_asm (Slither line:1637)


Begin OpenDiamond.find_delegatecall_in_asm (Slither line:1541)


End OpenDiamond.find_delegatecall_in_asm (Slither line:1637)

NEW VARIABLE (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)

EXPRESSION (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)


Begin OpenDiamond.find_delegatecall_in_exp_node

Found Expression Node: require(bool,string)(facet != address(0),Diamond: Function does not exist) (Slither line:2792)
Expression called: require(bool,string)
Type of call: tuple() (Slither line:2807)
Args:
facet != address(0)
Diamond: Function does not exist

End OpenDiamond.find_delegatecall_in_exp_node (Slither line:2848)

EXPRESSION (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)


Begin OpenDiamond.find_delegatecall_in_exp_node

Found Expression Node: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()()) (Slither line:2792)
Expression called: returndatacopy(uint256,uint256,uint256)
Type of call:  (Slither line:2807)
Args:
0
0
returndatasize()()

End OpenDiamond.find_delegatecall_in_exp_node (Slither line:2848)

NEW VARIABLE (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)

EXPRESSION (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2727)


End Contract.find_delegatecall_in_ir (Slither line:2763)


Begin OpenDiamond.find_delegatecall_in_exp_node

Found Expression Node: result_fallback_asm_1 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),facet,0,calldatasize()(),0,0) (Slither line:2792)
Expression Type: = (Slither line:2795)
Checking right side of assignment expression... (Slither line:2803)
Expression called: delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)
Type of call: uint256 (Slither line:2807)
Args:
gas()()
facet
0
calldatasize()()
0
0

Found delegatecall in expression:
delegatecall(uint256,uint256,uint256,uint256,uint256,uint256) (Slither line:2814)

Destination is facet (Slither line:2818)
dest.value: facet (Slither line:2821)
Expression: ds.facetAddressAndSelectorPosition[msg.sig].facetAddress (Slither line:2826)

End OpenDiamond.find_delegatecall_in_exp_node (Slither line:2848)


End OpenDiamond.is_proxy (Slither line:1476)


Begin OpenDiamond.is_upgradeable_proxy (Slither line:1136)

Checking contract: OpenDiamond 
Local Variable: facet (Slither line:1164)
OpenDiamond is delegating to facet
Looking for setter (Slither line:1200)


Begin OpenDiamond.find_setter_in_contract (Slither line:3109)

Expression: ds.facetAddressAndSelectorPosition[msg.sig].facetAddress (Slither line:3112)
Checking function: constructor(address,address) returns() (Slither line:3117)
Checking function: fallback() returns() (Slither line:3117)
Checking function: addFairPriceAddress(bytes32,address) returns() (Slither line:3117)
Visibility: external
ds = position
is an Assignment Operation (Slither line:3206)
ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
ds.pairAddresses[_market] = _address
is an Assignment Operation (Slither line:3206)
ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
LibDiamond._addFairPriceAddress(_market,_address)
Checking function: getFairPriceAddress(bytes32) returns(address) (Slither line:3117)
Visibility: external
LibDiamond._getFairPriceAddress(_market)
ds = position
is an Assignment Operation (Slither line:3206)
ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
ds.pairAddresses[_market]
Checking function: receive() returns() (Slither line:3117)

Begin DiamondCut corner case handling (Slither line:3277)

Expression: require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(0),LibDiamondCut: Can't remove function that doesn't exist) (Slither line:3284)
require(bool,string)
Expression: require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(this),LibDiamondCut: Can't remove immutable function.) (Slither line:3284)
require(bool,string)
Expression: selectorCount -- (Slither line:3284)
Expression type: -- (Slither line:3286)
Expression: ds.selectors.pop() (Slither line:3284)
ds.selectors.pop
Expression: ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: delete ds.facetAddressAndSelectorPosition[selector] (Slither line:3284)
Expression type: delete (Slither line:3286)
Expression: require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut) (Slither line:3284)
require(bool,string)
Expression: ds._adminRoles[role]._adminMembers[account] = true (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: AdminRoleDataGranted(role,account,msg.sender) (Slither line:3284)
AdminRoleDataGranted
Expression: require(bool,string)(_facetAddress == address(0),LibDiamondCut: Remove facet address must be address(0)) (Slither line:3284)
require(bool,string)
Expression: authContract(ACCESSREGISTRY_ID) (Slither line:3284)
authContract
Expression: require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut) (Slither line:3284)
require(bool,string)
Expression: facetIndex ++ (Slither line:3284)
Expression type: ++ (Slither line:3286)
Expression: require(bool,string)(_facetAddress != address(0),LibDiamondCut: Replace facet can't be address(0)) (Slither line:3284)
require(bool,string)
Expression: enforceHasContractCode(_facetAddress,LibDiamondCut: Replace facet has no code) (Slither line:3284)
enforceHasContractCode
Expression: initializeDiamondCut(_init,_calldata) (Slither line:3284)
initializeDiamondCut
Expression: require(bool,string)(_calldata.length == 0,LibDiamondCut: _init is address(0) but_calldata is not empty) (Slither line:3284)
require(bool,string)
Expression: selectorIndex ++ (Slither line:3284)
Expression type: ++ (Slither line:3286)
Expression: DiamondCut(_diamondCut,_init,_calldata) (Slither line:3284)
DiamondCut
Expression: require(bool,string)(_facetId == LibDiamond.diamondStorage().facetAddressAndSelectorPosition[msg.sig].facetId || LibDiamond.diamondStorage().facetAddressAndSelectorPosition[msg.sig].facetId == 0,Not permitted) (Slither line:3284)
require(bool,string)
Expression: addFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors,_diamondCut[facetIndex].facetId) (Slither line:3284)
addFunctions
Expression: require(bool,string)(_calldata.length > 0,LibDiamondCut: _calldata is empty but _init is not address(0)) (Slither line:3284)
require(bool,string)
Expression: require(bool,string)(contractSize > 0,_errorMessage) (Slither line:3284)
require(bool,string)
Expression: contractSize = extcodesize(uint256)(_contract) (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: replaceFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors,_diamondCut[facetIndex].facetId) (Slither line:3284)
replaceFunctions
Expression: ds = position (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut) (Slither line:3284)
require(bool,string)
Expression: enforceHasContractCode(_init,LibDiamondCut: _init address has no code) (Slither line:3284)
enforceHasContractCode
Expression: selectorIndex ++ (Slither line:3284)
Expression type: ++ (Slither line:3286)
Expression: (success,error) = _init.delegatecall(_calldata) (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors) (Slither line:3284)
removeFunctions
Expression: require(bool,string)(_facetAddress != address(0),LibDiamondCut: Add facet can't be address(0)) (Slither line:3284)
require(bool,string)
Expression: require(bool,string)(oldFacetAddress != address(this),LibDiamondCut: Can't replace immutable function) (Slither line:3284)
require(bool,string)
Expression: enforceHasContractCode(_facetAddress,LibDiamondCut: Add facet has no code) (Slither line:3284)
enforceHasContractCode
Expression: require(bool,string)(oldFacetAddress != _facetAddress,LibDiamondCut: Can't replace function with same function) (Slither line:3284)
require(bool,string)
Expression: revert(string)(LibDiamondCut: Incorrect FacetCutAction) (Slither line:3284)
revert(string)
Expression: require(bool,string)(oldFacetAddress != address(0),LibDiamondCut: Can't replace function that doesn't exist) (Slither line:3284)
require(bool,string)
Expression: ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: ds.facetAddressAndSelectorPosition[selector].facetId = _facetId (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: ds.contractOwner = _newOwner (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: ds.superAdmin = keccak256(bytes)(AccessRegistry.admin) (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: revert(string)(string(error)) (Slither line:3284)
revert(string)
Expression: _addAdminRole(keccak256(bytes)(AccessRegistry.admin),_newOwner) (Slither line:3284)
_addAdminRole
Expression: OwnershipTransferred(previousOwner,_newOwner) (Slither line:3284)
OwnershipTransferred
Expression: revert(string)(LibDiamondCut: _init function reverted) (Slither line:3284)
revert(string)
Expression: selectorIndex ++ (Slither line:3284)
Expression type: ++ (Slither line:3286)
Expression: require(bool,string)(oldFacetAddress == address(0),LibDiamondCut: Can't add function that already exists) (Slither line:3284)
require(bool,string)
Expression: ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress,selectorCount,_facetId) (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: LibDiamond.setContractOwner(_contractOwner) (Slither line:3284)
LibDiamond.setContractOwner
Expression: ds.selectors.push(selector) (Slither line:3284)
ds.selectors.push
Expression: selectorCount ++ (Slither line:3284)
Expression type: ++ (Slither line:3286)
Expression: functionSelectors[0] = IDiamondCut.diamondCut.selector (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: cut[0] = IDiamondCut.FacetCut(_diamondCutFacet,IDiamondCut.FacetCutAction.Add,functionSelectors,0) (Slither line:3284)
Expression type: = (Slither line:3286)
Expression: LibDiamond.diamondCut(cut,address(0),) (Slither line:3284)
LibDiamond.diamondCut

End DiamondCut corner case handling (Slither line:3313)


End OpenDiamond.find_setter_in_contract (Slither line:3315)


Implementation set by function: diamondCut in contract: LibDiamond (Slither line:1264)
Looking for getter (Slither line:1273)


Begin OpenDiamond.find_getter_in_contract (Slither line:2964)

facet is a Variable object
ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
Checking function: constructor (Slither line:2978)
Checking function: fallback (Slither line:2978)
Checking function: addFairPriceAddress (Slither line:2978)
Checking function: getFairPriceAddress (Slither line:2978)
getFairPriceAddress returns address variable  (Slither line:2998)
RETURN node expression: LibDiamond._getFairPriceAddress(_market) (Slither line:3018)
Checking function: receive (Slither line:2978)

End OpenDiamond.find_getter_in_contract (Slither line:3073)

Could not find implementation getter in OpenDiamond (Slither line:1305)

Begin Context.find_getter_in_contract (Slither line:2964)

facet is a Variable object
ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
Checking function: _msgSender (Slither line:2978)
_msgSender returns address variable  (Slither line:2998)
RETURN node expression: msg.sender (Slither line:3018)
Checking function: _msgData (Slither line:2978)
_msgData returns bytes variable  (Slither line:2998)
RETURN node expression: msg.data (Slither line:3018)
Checking function: _msgValue (Slither line:2978)
_msgValue returns uint256 variable  (Slither line:2998)
RETURN node expression: msg.value (Slither line:3018)

End Context.find_getter_in_contract (Slither line:3073)

Looking for Loupe functions in Context
_msgSender() returns(address)
_msgData() returns(bytes)
_msgValue() returns(uint256)
Looking for Loupe functions in Pausable
_msgSender() returns(address)
_msgData() returns(bytes)
_msgValue() returns(uint256)
constructor() returns()
_pause() returns()
_unpause() returns()
_paused() returns(bool)
_checkPauseState() returns()
slitherConstructorVariables() returns()
Looking for Loupe functions in Address
isContract(address) returns(bool)
sendValue(address,uint256) returns()
functionCall(address,bytes) returns(bytes)
functionCall(address,bytes,string) returns(bytes)
functionCallWithValue(address,bytes,uint256) returns(bytes)
functionCallWithValue(address,bytes,uint256,string) returns(bytes)
_functionCallWithValue(address,bytes,uint256,string) returns(bytes)
Looking for Loupe functions in LibDiamond
_isMarketSupported(bytes32) returns()
_addMarketSupport(bytes32,uint256,address,uint256) returns()
_removeMarketSupport(bytes32) returns()
_updateMarketSupport(bytes32,uint256,address) returns()
_getMarketAddress(bytes32) returns(address)
_getMarketDecimal(bytes32) returns(uint256)
_minAmountCheck(bytes32,uint256) returns()
_isMarket2Supported(bytes32) returns()
_getMarket2Address(bytes32) returns(address)
_addMarket2Support(bytes32,uint256,address) returns()
_removeMarket2Support(bytes32) returns()
_updateMarket2Support(bytes32,uint256,address) returns()
_getMarket2Decimal(bytes32) returns(uint256)
_connectMarket(bytes32) returns(address)
_getAPR(bytes32) returns(uint256)
_getAPRInd(bytes32,uint256) returns(uint256)
_getAPY(bytes32) returns(uint256)
_getAPYInd(bytes32,uint256) returns(uint256)
_getApytime(bytes32,uint256) returns(uint256)
_getAprtime(bytes32,uint256) returns(uint256)
_getApyLastTime(bytes32) returns(uint256)
_getAprLastTime(bytes32) returns(uint256)
_getApyTimeLength(bytes32) returns(uint256)
_getAprTimeLength(bytes32) returns(uint256)
_getCommitment(uint256) returns(bytes32)
_updateApy(bytes32,uint256) returns(bool)
_setCommitment(bytes32) returns()
_updateApr(bytes32,uint256) returns(bool)
_calcAPR(bytes32,uint256,uint256,uint256) returns(uint256,uint256)
_calcAPY(bytes32,uint256,uint256,uint256) returns(uint256,uint256)
_getReserveFactor() returns(uint256)
_swap(bytes32,bytes32,uint256,uint8) returns(uint256)
_getAmountOutMin(address,address,uint256) returns(uint256)
_hasDeposit(address,bytes32,bytes32) returns(bool)
_avblReservesDeposit(bytes32) returns(uint256)
_utilisedReservesDeposit(bytes32) returns(uint256)
_avblReservesLoan(bytes32) returns(uint256)
_utilisedReservesLoan(bytes32) returns(uint256)
_withdrawDeposit(address,bytes32,bytes32,uint256,IDeposit.SAVINGSTYPE) returns()
_accruedYield(address,bytes32,bytes32) returns()
_preDepositProcess(bytes32,uint256) returns()
_processNewDeposit(bytes32,bytes32,uint256,LibDiamond.SavingsAccount,LibDiamond.DepositRecords,LibDiamond.YieldLedger) returns()
_processDeposit(address,bytes32,bytes32,uint256) returns()
_hasAccount(address) returns()
_hasYield(LibDiamond.YieldLedger) returns()
_accountBalance(address,bytes32,bytes32,IDeposit.SAVINGSTYPE) returns(uint256)
_updateSavingsBalance(address,bytes32,bytes32,uint256,IDeposit.SAVINGSTYPE) returns()
_updateReservesDeposit(bytes32,uint256,uint256) returns()
_createNewDeposit(bytes32,bytes32,uint256,address) returns()
_addToDeposit(address,bytes32,bytes32,uint256) returns()
_ensureSavingsAccount(address,LibDiamond.SavingsAccount) returns()
_convertYield(address,bytes32,bytes32,uint256) returns()
_updateReservesLoan(bytes32,uint256,uint256) returns()
_updateUtilisationLoan(bytes32,uint256,uint256) returns()
_swapToLoan(address,bytes32,bytes32,bytes32,uint256) returns(bool)
_swapToLoanProcess(address,bytes32,bytes32,bytes32,uint256) returns(bool)
_withdrawCollateral(address,bytes32,bytes32) returns()
_collateralPointer(address,bytes32,bytes32,bytes32,uint256) returns()
_accruedYield(LibDiamond.LoanAccount,LibDiamond.CollateralRecords,LibDiamond.CollateralYield) returns()
_updateDebtRecords(LibDiamond.LoanAccount,LibDiamond.LoanRecords,LibDiamond.LoanState,LibDiamond.CollateralRecords) returns()
_accruedInterest(address,bytes32,bytes32) returns()
_checkPermissibleWithdrawal(bytes32,bytes32,bytes32,uint256,address) returns()
_repaymentProcess(address,uint256,LibDiamond.LoanAccount,LibDiamond.LoanRecords,LibDiamond.LoanState,LibDiamond.CollateralRecords,LibDiamond.DeductibleInterest,LibDiamond.CollateralYield) returns()
_preLoanRequestProcess(bytes32,uint256,bytes32,uint256) returns()
_processNewLoan(address,bytes32,bytes32,uint256,bytes32,uint256) returns()
_preAddCollateralProcess(bytes32,uint256,LibDiamond.LoanAccount,LibDiamond.LoanRecords,LibDiamond.LoanState,LibDiamond.CollateralRecords) returns()
_ensureLoanAccount(address) returns()
_permissibleCDR(bytes32,bytes32,uint256,uint256) returns()
_addCollateral(bytes32,bytes32,bytes32,uint256,address) returns()
_addCollateralAmount(LibDiamond.LoanAccount,LibDiamond.CollateralRecords,uint256,uint256) returns()
_swapLoan(address,bytes32,bytes32,bytes32) returns()
_loanRequest(bytes32,bytes32,uint256,bytes32,uint256,address) returns()
_repayLoan(bytes32,bytes32,uint256,address) returns()
_hasLoanAccount(address) returns(bool)
_permissibleWithdrawal(bytes32,bytes32,bytes32,uint256,address) returns(bool)
_liquidation(address,uint256) returns()
_collateralTransfer(address,bytes32,bytes32) returns()
_transferAnyBEP20(address,address,address,uint256) returns()
_avblMarketReserves(bytes32) returns(uint256)
_marketReserves(bytes32) returns(uint256)
_marketUtilisation(bytes32) returns(uint256)
_getLatestPrice(bytes32) returns(uint256)
_getFairPrice(uint256) returns(uint256)
_fairPrice(uint256,uint256,bytes32,uint256) returns()
_hasRole(bytes32,address) returns(bool)
_addRole(bytes32,address) returns()
_revokeRole(bytes32,address) returns()
_hasAdminRole(bytes32,address) returns(bool)
_addAdminRole(bytes32,address) returns()
_revokeAdmin(bytes32,address) returns()
diamondStorage() returns(LibDiamond.DiamondStorage)
setContractOwner(address) returns()
_addFairPriceAddress(bytes32,address) returns()
_getFairPriceAddress(bytes32) returns(address)
contractOwner() returns(address)
enforceIsContractOwner() returns()
diamondCut(IDiamondCut.FacetCut[],address,bytes) returns()
addFunctions(address,bytes4[],uint8) returns()
replaceFunctions(address,bytes4[],uint8) returns()
removeFunctions(address,bytes4[]) returns()
initializeDiamondCut(address,bytes) returns()
enforceHasContractCode(address,string) returns()
slitherConstructorConstantVariables() returns()
impl_address_from_contract_call: ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
Checking external function addFairPriceAddress
Checking external function getFairPriceAddress
Checking external function fallback
Checking external function receive
functions_writing_to_variable: facet
functions_writing_to_variable: checking function LibDiamond._hasAccount (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._removeMarketSupport (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addRole (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAPY (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._hasYield (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateMarketSupport (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.slitherConstructorConstantVariables (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAPYInd (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._revokeRole (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._accountBalance (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getMarketAddress (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getApytime (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._hasAdminRole (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateSavingsBalance (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getMarketDecimal (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAprtime (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addAdminRole (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateReservesDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._minAmountCheck (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getApyLastTime (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._createNewDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._revokeAdmin (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._isMarket2Supported (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAprLastTime (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addToDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.diamondStorage (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getMarket2Address (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getApyTimeLength (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._ensureSavingsAccount (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.setContractOwner (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addMarket2Support (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAprTimeLength (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._convertYield (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addFairPriceAddress (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._removeMarket2Support (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getCommitment (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateReservesLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getFairPriceAddress (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateMarket2Support (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateApy (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateUtilisationLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.contractOwner (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getMarket2Decimal (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._setCommitment (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._swapToLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.enforceIsContractOwner (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._connectMarket (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateApr (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._swapToLoanProcess (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.diamondCut (proxy_features line:893)
get_value_assigned: ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress
functions_writing_to_variable: diamondCut writes _facetAddress to ds.facetAddressAndSelectorPosition[selector].facetAddress (proxy_features line:1033)
functions_writing_to_variable: checking function LibDiamond._getAPR (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._calcAPR (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._withdrawCollateral (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.addFunctions (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAPRInd (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._calcAPY (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._collateralPointer (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._loanRequest (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.replaceFunctions (proxy_features line:893)
get_value_assigned: ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress
functions_writing_to_variable: replaceFunctions writes _facetAddress to ds.facetAddressAndSelectorPosition[selector].facetAddress (proxy_features line:1033)
functions_writing_to_variable: checking function LibDiamond._getReserveFactor (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._accruedYield (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._repayLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.removeFunctions (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._swap (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._updateDebtRecords (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._hasLoanAccount (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.initializeDiamondCut (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getAmountOutMin (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._accruedInterest (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._permissibleWithdrawal (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond.enforceHasContractCode (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._hasDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._checkPermissibleWithdrawal (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._liquidation (proxy_features line:893)
functions_writing_to_variable: checking function OpenDiamond.constructor (proxy_features line:893)
get_value_assigned: ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress
functions_writing_to_variable: constructor writes _facetAddress to ds.facetAddressAndSelectorPosition[selector].facetAddress (proxy_features line:1033)
functions_writing_to_variable: checking function LibDiamond._avblReservesDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._repaymentProcess (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._collateralTransfer (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._utilisedReservesDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._preLoanRequestProcess (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._transferAnyBEP20 (proxy_features line:893)
functions_writing_to_variable: checking function OpenDiamond.addFairPriceAddress (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._avblReservesLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._processNewLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._avblMarketReserves (proxy_features line:893)
functions_writing_to_variable: checking function OpenDiamond.getFairPriceAddress (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._utilisedReservesLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._preAddCollateralProcess (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._marketReserves (proxy_features line:893)
functions_writing_to_variable: checking function OpenDiamond.receive (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._withdrawDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._ensureLoanAccount (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._marketUtilisation (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._accruedYield (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._permissibleCDR (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getLatestPrice (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._preDepositProcess (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addCollateral (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._getFairPrice (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._processNewDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addCollateralAmount (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._isMarketSupported (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._fairPrice (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._processDeposit (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._swapLoan (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._addMarketSupport (proxy_features line:893)
functions_writing_to_variable: checking function LibDiamond._hasRole (proxy_features line:893)
has_compatibility_checks: dependencies: ['ds', 'REF_1802', 'REF_1800', 'REF_1801']
has_compatibility_checks: checking internal function diamondCut
require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(0),LibDiamondCut: Can't remove function that doesn't exist)
has_compatibility_checks: condition oldFacetAddressAndSelectorPosition.facetAddress != address(0)
require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(this),LibDiamondCut: Can't remove immutable function.)
has_compatibility_checks: condition oldFacetAddressAndSelectorPosition.facetAddress != address(this)
has_compatibility_checks: IF node exp = oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount
require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_compatibility_checks: condition _functionSelectors.length > 0
require(bool,string)(_facetAddress == address(0),LibDiamondCut: Remove facet address must be address(0))
has_compatibility_checks: condition _facetAddress == address(0)
check_condition_from_expression: condition _facetAddress == address(0)
require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_compatibility_checks: condition _functionSelectors.length > 0
require(bool,string)(_facetAddress != address(0),LibDiamondCut: Replace facet can't be address(0))
has_compatibility_checks: condition _facetAddress != address(0)
check_condition_from_expression: condition _facetAddress != address(0)
has_compatibility_checks: IF node exp = _init == address(0)
has_compatibility_checks: IF node exp = action == IDiamondCut.FacetCutAction.Add
require(bool,string)(_calldata.length == 0,LibDiamondCut: _init is address(0) but_calldata is not empty)
has_compatibility_checks: condition _calldata.length == 0
require(bool,string)(_calldata.length > 0,LibDiamondCut: _calldata is empty but _init is not address(0))
has_compatibility_checks: condition _calldata.length > 0
has_compatibility_checks: IF node exp = action == IDiamondCut.FacetCutAction.Replace
require(bool,string)(contractSize > 0,_errorMessage)
has_compatibility_checks: condition contractSize > 0
has_compatibility_checks: IF node exp = _init != address(this)
has_compatibility_checks: IF node exp = ! success
require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_compatibility_checks: condition _functionSelectors.length > 0
has_compatibility_checks: IF node exp = action == IDiamondCut.FacetCutAction.Remove
has_compatibility_checks: IF node can lead to revert ['removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors)', 'revert(string)(LibDiamondCut: Incorrect FacetCutAction)']
has_compatibility_checks: IF node can lead to revert ['removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors)', 'revert(string)(LibDiamondCut: Incorrect FacetCutAction)']
has_compatibility_checks: ConditionalExpression if action == IDiamondCut.FacetCutAction.Remove then removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors) else revert(string)(LibDiamondCut: Incorrect FacetCutAction)
require(bool,string)(_facetAddress != address(0),LibDiamondCut: Add facet can't be address(0))
has_compatibility_checks: condition _facetAddress != address(0)
check_condition_from_expression: condition _facetAddress != address(0)
require(bool,string)(oldFacetAddress != address(this),LibDiamondCut: Can't replace immutable function)
has_compatibility_checks: condition oldFacetAddress != address(this)
require(bool,string)(oldFacetAddress != _facetAddress,LibDiamondCut: Can't replace function with same function)
has_compatibility_checks: condition oldFacetAddress != _facetAddress
check_condition_from_expression: condition ds.facetAddressAndSelectorPosition[selector].facetAddress != _facetAddress
require(bool,string)(oldFacetAddress != address(0),LibDiamondCut: Can't replace function that doesn't exist)
has_compatibility_checks: condition oldFacetAddress != address(0)
has_compatibility_checks: IF node exp = error.length > 0
has_compatibility_checks: IF node can lead to revert ['revert(string)(string(error))', 'revert(string)(LibDiamondCut: _init function reverted)']
has_compatibility_checks: IF node can lead to revert ['revert(string)(string(error))', 'revert(string)(LibDiamondCut: _init function reverted)']
has_compatibility_checks: ConditionalExpression if error.length > 0 then revert(string)(string(error)) else revert(string)(LibDiamondCut: _init function reverted)
require(bool,string)(oldFacetAddress == address(0),LibDiamondCut: Can't add function that already exists)
has_compatibility_checks: condition oldFacetAddress == address(0)
has_compatibility_checks: skipping internal function replaceFunctions
has_compatibility_checks: checking public function constructor
require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(0),LibDiamondCut: Can't remove function that doesn't exist)
has_compatibility_checks: condition oldFacetAddressAndSelectorPosition.facetAddress != address(0)
require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(this),LibDiamondCut: Can't remove immutable function.)
has_compatibility_checks: condition oldFacetAddressAndSelectorPosition.facetAddress != address(this)
has_compatibility_checks: IF node exp = oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount
require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_compatibility_checks: condition _functionSelectors.length > 0
require(bool,string)(_facetAddress == address(0),LibDiamondCut: Remove facet address must be address(0))
has_compatibility_checks: condition _facetAddress == address(0)
check_condition_from_expression: condition _facetAddress == address(0)
require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_compatibility_checks: condition _functionSelectors.length > 0
require(bool,string)(_facetAddress != address(0),LibDiamondCut: Replace facet can't be address(0))
has_compatibility_checks: condition _facetAddress != address(0)
check_condition_from_expression: condition _facetAddress != address(0)
has_compatibility_checks: IF node exp = _init == address(0)
has_compatibility_checks: IF node exp = action == IDiamondCut.FacetCutAction.Add
require(bool,string)(_calldata.length == 0,LibDiamondCut: _init is address(0) but_calldata is not empty)
has_compatibility_checks: condition _calldata.length == 0
require(bool,string)(_facetId == LibDiamond.diamondStorage().facetAddressAndSelectorPosition[msg.sig].facetId || LibDiamond.diamondStorage().facetAddressAndSelectorPosition[msg.sig].facetId == 0,Not permitted)
has_compatibility_checks: condition _facetId == LibDiamond.diamondStorage().facetAddressAndSelectorPosition[msg.sig].facetId || LibDiamond.diamondStorage().facetAddressAndSelectorPosition[msg.sig].facetId == 0
require(bool,string)(_calldata.length > 0,LibDiamondCut: _calldata is empty but _init is not address(0))
has_compatibility_checks: condition _calldata.length > 0
has_compatibility_checks: IF node exp = action == IDiamondCut.FacetCutAction.Replace
require(bool,string)(contractSize > 0,_errorMessage)
has_compatibility_checks: condition contractSize > 0
has_compatibility_checks: IF node exp = _init != address(this)
has_compatibility_checks: IF node exp = ! success
require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_compatibility_checks: condition _functionSelectors.length > 0
has_compatibility_checks: IF node exp = action == IDiamondCut.FacetCutAction.Remove
has_compatibility_checks: IF node can lead to revert ['removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors)', 'revert(string)(LibDiamondCut: Incorrect FacetCutAction)']
has_compatibility_checks: IF node can lead to revert ['removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors)', 'revert(string)(LibDiamondCut: Incorrect FacetCutAction)']
has_compatibility_checks: ConditionalExpression if action == IDiamondCut.FacetCutAction.Remove then removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors) else revert(string)(LibDiamondCut: Incorrect FacetCutAction)
require(bool,string)(_facetAddress != address(0),LibDiamondCut: Add facet can't be address(0))
has_compatibility_checks: condition _facetAddress != address(0)
check_condition_from_expression: condition _facetAddress != address(0)
require(bool,string)(oldFacetAddress != address(this),LibDiamondCut: Can't replace immutable function)
has_compatibility_checks: condition oldFacetAddress != address(this)
require(bool,string)(oldFacetAddress != _facetAddress,LibDiamondCut: Can't replace function with same function)
has_compatibility_checks: condition oldFacetAddress != _facetAddress
check_condition_from_expression: condition ds.facetAddressAndSelectorPosition[selector].facetAddress != _facetAddress
require(bool,string)(oldFacetAddress != address(0),LibDiamondCut: Can't replace function that doesn't exist)
has_compatibility_checks: condition oldFacetAddress != address(0)
has_compatibility_checks: IF node exp = error.length > 0
has_compatibility_checks: IF node can lead to revert ['revert(string)(string(error))', 'revert(string)(LibDiamondCut: _init function reverted)']
has_compatibility_checks: IF node can lead to revert ['revert(string)(string(error))', 'revert(string)(LibDiamondCut: _init function reverted)']
has_compatibility_checks: ConditionalExpression if error.length > 0 then revert(string)(string(error)) else revert(string)(LibDiamondCut: _init function reverted)
require(bool,string)(oldFacetAddress == address(0),LibDiamondCut: Can't add function that already exists)
has_compatibility_checks: condition oldFacetAddress == address(0)
can_toggle_delegatecall_on_off: found delegatecall in EXPRESSION node: None
can_toggle_delegatecall_on_off:
 dominator node type: NEW VARIABLE
 dominator expression: facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress
can_toggle_delegatecall_on_off:
 dominator node type: EXPRESSION
 dominator expression: calldatacopy(uint256,uint256,uint256)(0,0,calldatasize()())
can_toggle_delegatecall_on_off:
 dominator node type: INLINE ASM
 dominator expression: None
can_toggle_delegatecall_on_off:
 dominator node type: EXPRESSION
 dominator expression: require(bool,string)(facet != address(0),Diamond: Function does not exist)
can_toggle_delegatecall_on_off:
 dominator node type: NEW VARIABLE
 dominator expression: None
can_toggle_delegatecall_on_off:
 dominator node type: EXPRESSION
 dominator expression: result_fallback_asm_1 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),facet,0,calldatasize()(),0,0)
can_toggle_delegatecall_on_off:
 dominator node type: ENTRY_POINT
 dominator expression: None
can_toggle_delegatecall_on_off:
 dominator node type: EXPRESSION
 dominator expression: ds = position
can_toggle_delegatecall_on_off:
 dominator node type: INLINE ASM
 dominator expression: None
can_toggle_delegatecall_on_off:
 dominator node type: NEW VARIABLE
 dominator expression: position = LibDiamond.DIAMOND_STORAGE_POSITION
can_toggle_delegatecall_on_off:
 dominator node type: NEW VARIABLE
 dominator expression: None
Found public function: constructor
Found fallback
Found external function: addFairPriceAddress
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(0),LibDiamondCut: Can't remove function that doesn't exist)
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(oldFacetAddressAndSelectorPosition.facetAddress != address(this),LibDiamondCut: Can't remove immutable function.)
has_time_delay: (node.type) EXPRESSION
(Expression) selectorCount --
has_time_delay: (node.type) IF
(Expression) oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount
has_time_delay: (node.type) EXPRESSION
(Expression) ds.selectors.pop()
has_time_delay: (node.type) NEW VARIABLE
(Expression) lastSelector = ds.selectors[selectorCount]
has_time_delay: (node.type) EXPRESSION
(Expression) ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector
has_time_delay: (node.type) EXPRESSION
(Expression) ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition
has_time_delay: (node.type) EXPRESSION
(Expression) delete ds.facetAddressAndSelectorPosition[selector]
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_time_delay: (node.type) NEW VARIABLE
(Expression) ds = diamondStorage()
has_time_delay: (node.type) NEW VARIABLE
(Expression) selectorCount = ds.selectors.length
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_facetAddress == address(0),LibDiamondCut: Remove facet address must be address(0))
has_time_delay: (node.type) IF_LOOP
(Expression) facetIndex < _diamondCut.length
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_time_delay: (node.type) EXPRESSION
(Expression) facetIndex ++
has_time_delay: (node.type) NEW VARIABLE
(Expression) ds = diamondStorage()
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_facetAddress != address(0),LibDiamondCut: Replace facet can't be address(0))
has_time_delay: (node.type) IF
(Expression) _init == address(0)
has_time_delay: (node.type) NEW VARIABLE
(Expression) action = _diamondCut[facetIndex].action
has_time_delay: (node.type) EXPRESSION
(Expression) enforceHasContractCode(_facetAddress,LibDiamondCut: Replace facet has no code)
has_time_delay: (node.type) IF_LOOP
(Expression) selectorIndex < _functionSelectors.length
has_time_delay: (node.type) IF
(Expression) action == IDiamondCut.FacetCutAction.Add
has_time_delay: (node.type) EXPRESSION
(Expression) initializeDiamondCut(_init,_calldata)
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_calldata.length == 0,LibDiamondCut: _init is address(0) but_calldata is not empty)
has_time_delay: (node.type) EXPRESSION
(Expression) selectorIndex ++
has_time_delay: (node.type) EXPRESSION
(Expression) DiamondCut(_diamondCut,_init,_calldata)
has_time_delay: (node.type) EXPRESSION
(Expression) addFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors,_diamondCut[facetIndex].facetId)
has_time_delay: (node.type) NEW VARIABLE
(Expression) selector = _functionSelectors[selectorIndex]
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_calldata.length > 0,LibDiamondCut: _calldata is empty but _init is not address(0))
has_time_delay: (node.type) IF
(Expression) action == IDiamondCut.FacetCutAction.Replace
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(contractSize > 0,_errorMessage)
has_time_delay: (node.type) IF
(Expression) _init != address(this)
has_time_delay: (node.type) NEW VARIABLE
(Expression) oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector]
has_time_delay: (node.type) EXPRESSION
(Expression) contractSize = extcodesize(uint256)(_contract)
has_time_delay: (node.type) IF_LOOP
(Expression) selectorIndex < _functionSelectors.length
has_time_delay: (node.type) IF
(Expression) ! success
has_time_delay: (node.type) EXPRESSION
(Expression) replaceFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors,_diamondCut[facetIndex].facetId)
has_time_delay: (node.type) EXPRESSION
(Expression) ds = position
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_functionSelectors.length > 0,LibDiamondCut: No selectors in facet to cut)
has_time_delay: (node.type) EXPRESSION
(Expression) enforceHasContractCode(_init,LibDiamondCut: _init address has no code)
has_time_delay: (node.type) IF
(Expression) action == IDiamondCut.FacetCutAction.Remove
has_time_delay: (node.type) EXPRESSION
(Expression) selectorIndex ++
has_time_delay: (node.type) NEW VARIABLE
(Expression) ds = diamondStorage()
has_time_delay: (node.type) NEW VARIABLE
(Expression) selector = _functionSelectors[selectorIndex]
has_time_delay: (node.type) EXPRESSION
(Expression) (success,error) = _init.delegatecall(_calldata)
has_time_delay: (node.type) NEW VARIABLE
(Expression) selectorCount = uint16(ds.selectors.length)
has_time_delay: (node.type) EXPRESSION
(Expression) removeFunctions(_diamondCut[facetIndex].facetAddress,_diamondCut[facetIndex].functionSelectors)
has_time_delay: (node.type) NEW VARIABLE
(Expression) oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(_facetAddress != address(0),LibDiamondCut: Add facet can't be address(0))
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(oldFacetAddress != address(this),LibDiamondCut: Can't replace immutable function)
has_time_delay: (node.type) EXPRESSION
(Expression) enforceHasContractCode(_facetAddress,LibDiamondCut: Add facet has no code)
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(oldFacetAddress != _facetAddress,LibDiamondCut: Can't replace function with same function)
has_time_delay: (node.type) EXPRESSION
(Expression) revert(string)(LibDiamondCut: Incorrect FacetCutAction)
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(oldFacetAddress != address(0),LibDiamondCut: Can't replace function that doesn't exist)
has_time_delay: (node.type) EXPRESSION
(Expression) ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress
has_time_delay: (node.type) IF
(Expression) error.length > 0
has_time_delay: (node.type) EXPRESSION
(Expression) ds.facetAddressAndSelectorPosition[selector].facetId = _facetId
has_time_delay: (node.type) EXPRESSION
(Expression) revert(string)(string(error))
has_time_delay: (node.type) IF_LOOP
(Expression) selectorIndex < _functionSelectors.length
has_time_delay: (node.type) EXPRESSION
(Expression) revert(string)(LibDiamondCut: _init function reverted)
has_time_delay: (node.type) EXPRESSION
(Expression) selectorIndex ++
has_time_delay: (node.type) NEW VARIABLE
(Expression) selector = _functionSelectors[selectorIndex]
has_time_delay: (node.type) NEW VARIABLE
(Expression) oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress
has_time_delay: (node.type) EXPRESSION
(Expression) require(bool,string)(oldFacetAddress == address(0),LibDiamondCut: Can't add function that already exists)
has_time_delay: (node.type) EXPRESSION
(Expression) ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress,selectorCount,_facetId)
has_time_delay: (node.type) EXPRESSION
(Expression) ds.selectors.push(selector)
has_time_delay: (node.type) EXPRESSION
(Expression) selectorCount ++
has_time_delay: (node.type) NEW VARIABLE
(Expression) position = DIAMOND_STORAGE_POSITION
