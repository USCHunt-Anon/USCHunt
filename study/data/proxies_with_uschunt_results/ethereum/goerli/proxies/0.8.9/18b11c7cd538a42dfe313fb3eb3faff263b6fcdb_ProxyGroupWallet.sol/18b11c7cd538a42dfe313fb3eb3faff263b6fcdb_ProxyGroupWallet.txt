
Begin AbstractReverseRegistrar.is_proxy (Slither line:1425)


End AbstractReverseRegistrar.is_proxy (Slither line:1428)


Begin AbstractReverseRegistrar.is_upgradeable_proxy (Slither line:1136)

Checking contract: AbstractReverseRegistrar 

End AbstractReverseRegistrar.is_upgradeable_proxy (Slither line:1407)


Begin ProxyGroupWallet.is_proxy (Slither line:1425)

EXPRESSION (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2735)


End Contract.find_delegatecall_in_ir (Slither line:2771)


Begin ProxyGroupWallet.find_delegatecall_in_exp_node

Found Expression Node: success_fallback_asm_0 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),master_fallback_asm_0,ptr_fallback_asm_0,calldatasize()(),0,0) (Slither line:2800)
Expression Type: = (Slither line:2803)
Checking right side of assignment expression... (Slither line:2811)
Expression called: delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)
Type of call: uint256 (Slither line:2815)
Args:
gas()()
master_fallback_asm_0
ptr_fallback_asm_0
calldatasize()()
0
0

Found delegatecall in expression:
delegatecall(uint256,uint256,uint256,uint256,uint256,uint256) (Slither line:2822)

Destination is master_fallback_asm_0 (Slither line:2826)
dest.value: master_fallback_asm_0 (Slither line:2829)
Expression: None (Slither line:2834)

Begin ProxyGroupWallet.find_delegate_variable_from_name
Searching for master_fallback_asm_0 (Slither line:1674)

Searching State Variables (Slither line:1687)
Checking masterCopy (Slither line:1689)
Checking tArr (Slither line:1689)
Checking owners (Slither line:1689)
Checking GWF (Slither line:1689)
Checking structures (Slither line:1689)

Searching Local Variables (Slither line:1698)

Searching Parameter Variables (Slither line:1797)
fallback contains assembly, searching for sload (Slither line:1875)

End ProxyGroupWallet.find_delegate_variable_from_name (Slither line:1947)


End ProxyGroupWallet.find_delegatecall_in_exp_node (Slither line:2856)

NEW VARIABLE (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2735)


End Contract.find_delegatecall_in_ir (Slither line:2771)

INLINE ASM (Slither line:1433)

Begin Contract.find_delegatecall_in_ir (Slither line:2735)


End Contract.find_delegatecall_in_ir (Slither line:2771)


Found Assembly Node (Slither line:1447)


Begin ProxyGroupWallet.find_delegatecall_in_asm (Slither line:1541)


Found delegatecall in YulFunctionCall (Slither line:1563)
Destination param is called 'master'
Looking for corresponding Variable
Current function: fallback

Begin ProxyGroupWallet.find_delegate_variable_from_name
Searching for master (Slither line:1674)

Searching State Variables (Slither line:1687)
Checking masterCopy (Slither line:1689)
Checking tArr (Slither line:1689)
Checking owners (Slither line:1689)
Checking GWF (Slither line:1689)
Checking structures (Slither line:1689)

Searching Local Variables (Slither line:1698)

Searching Parameter Variables (Slither line:1797)
fallback contains assembly, searching for sload (Slither line:1875)
{'kind': 'number', 'nodeType': 'YulLiteral', 'src': '1706:1:0', 'type': '', 'value': '0'} (Slither line:1907)
Found sload(0), getting first state variable

End ProxyGroupWallet.find_delegate_variable_from_name (Slither line:1947)


End ProxyGroupWallet.find_delegatecall_in_asm (Slither line:1637)


End ProxyGroupWallet.is_proxy (Slither line:1476)


Begin ProxyGroupWallet.is_upgradeable_proxy (Slither line:1136)

Checking contract: ProxyGroupWallet 
ProxyGroupWallet is delegating to masterCopy
Looking for setter (Slither line:1200)


Begin ProxyGroupWallet.find_setter_in_contract (Slither line:3117)

Checking function: constructor(address,AbstractReverseRegistrar,string) returns() (Slither line:3125)
Checking function: fallback() returns() (Slither line:3125)

End ProxyGroupWallet.find_setter_in_contract (Slither line:3343)


Could not find implementation setter in ProxyGroupWallet (Slither line:1269)
Looking for getter (Slither line:1273)


Begin ProxyGroupWallet.find_getter_in_contract (Slither line:2972)

masterCopy is a Variable object
Checking function: constructor (Slither line:2986)
Checking function: fallback (Slither line:2986)

End ProxyGroupWallet.find_getter_in_contract (Slither line:3081)

Could not find implementation getter in ProxyGroupWallet (Slither line:1305)
Checking for masterCopy at slot 0 in contract AbstractGroupWalletFactory (Slither line:1355)
Found resolverContract at slot 0 in contract AbstractGroupWalletFactory (Slither line:1362)
Checking for resolverContract at slot 0 in contract AbstractBaseRegistrar (Slither line:1355)
Found baseNode at slot 0 in contract AbstractBaseRegistrar (Slither line:1362)
Checking for baseNode at slot 0 in contract AbstractResolver (Slither line:1355)
Found hashes at slot 0 in contract AbstractResolver (Slither line:1362)
Checking for hashes at slot 0 in contract AbstractETHRegistrarController (Slither line:1355)
Found commitments at slot 0 in contract AbstractETHRegistrarController (Slither line:1362)
Checking for commitments at slot 0 in contract GroupWalletMaster (Slither line:1355)
Found masterCopy at slot 0 in contract GroupWalletMaster (Slither line:1362)

Begin GroupWalletMaster.find_getter_in_contract (Slither line:2972)

masterCopy is a Variable object
Checking function: getMasterCopy (Slither line:2986)
getMasterCopy returns address variable  (Slither line:3006)
RETURN node expression: masterCopy (Slither line:3026)

End GroupWalletMaster.find_getter_in_contract (Slither line:3081)


Begin GroupWalletMaster.find_setter_in_contract (Slither line:3117)

Checking function: getMasterCopy() returns(address) (Slither line:3125)
Visibility: external
masterCopy
Checking function: getGWF() returns(address) (Slither line:3125)
Visibility: external
GWF
Checking function: getENS() returns(AbstractENS) (Slither line:3125)
Visibility: internal
Checking function: getRsv() returns(AbstractResolver) (Slither line:3125)
Visibility: internal
Checking function: getCtrl() returns(AbstractETHRegistrarController) (Slither line:3125)
Visibility: internal
Checking function: getTarget(uint256) returns(address) (Slither line:3125)
Visibility: private
Checking function: getTValue(uint256) returns(uint64) (Slither line:3125)
Visibility: private
Checking function: getAsset(uint256) returns(uint8) (Slither line:3125)
Visibility: private
Checking function: getFlags(uint256) returns(uint64) (Slither line:3125)
Visibility: private
Checking function: getType(uint256) returns(uint8) (Slither line:3125)
Visibility: private
Checking function: saveFlags(uint256,uint64) returns() (Slither line:3125)
Visibility: private
Checking function: saveAsset(uint256,uint8) returns() (Slither line:3125)
Visibility: private
Checking function: saveExecuted(uint256,uint64,uint256) returns() (Slither line:3125)
Visibility: private
Checking function: my_require(bool,string) returns() (Slither line:3125)
Visibility: private
Checking function: char(bytes1) returns(bytes1) (Slither line:3125)
Visibility: private
Checking function: bytesToStr(bytes32,uint256) returns(string) (Slither line:3125)
Visibility: internal
Checking function: bytes32ToStr(bytes32) returns(string) (Slither line:3125)
Visibility: internal
Checking function: toLowerCaseString(bytes32) returns(string) (Slither line:3125)
Visibility: internal
Checking function: bytes32ToAsciiString(bytes32,uint256) returns(string) (Slither line:3125)
Visibility: private
Checking function: strlen(string) returns(uint256) (Slither line:3125)
Visibility: internal
Checking function: concatString(bytes32,string) returns(string) (Slither line:3125)
Visibility: internal
Checking function: toLowerCaseBytes32(bytes32) returns(bytes32) (Slither line:3125)
Visibility: internal
Checking function: getT(uint256) returns(uint256) (Slither line:3125)
Visibility: internal
Checking function: dHashFromLabelBytes32(bytes32) returns(bytes32) (Slither line:3125)
Visibility: internal
Checking function: getdHashFromTRecord(uint256) returns(bytes32) (Slither line:3125)
Visibility: internal
Checking function: checkPreconditions(uint256,uint256,uint256) returns() (Slither line:3125)
Visibility: private
Checking function: checkSplitPreconditions(uint256,uint8) returns(uint256) (Slither line:3125)
Visibility: private
Checking function: tldOfChain() returns(string) (Slither line:3125)
Visibility: internal
Checking function: confirmTransaction_Q6d(uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
my_require((newMaj >= 2) && (newMaj <= MAX_OWNER_COUNT),required 2-31!!!)
f = (uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + uint64(newMaj)
is an Assignment Operation (Slither line:3214)
AbstractENS(AbstractGroupWalletFactory(GWF).ens())
count ++
saveExecuted(_tId,f,t)
getRsv().setAddr(l_dlabelHash,target)
0
None
AbstractGroupWalletFactory(GWF).resolverContract()
my_require(uint64(f & o) == 0,notConfirmed!!!)
i ++
my_require(uint8((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask) < 128,Q6d notExecuted!!!)
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
f = uint64(f | o)
is an Assignment Operation (Slither line:3214)
count
callExecution(_tId,t,f)
my_require(isAddressOwner(msg.sender), no owner)
(succ,returnData) = target.call{value: uint64((uint256(uint256(t) & k_valueMask) >> 160) & k_value2Mask) << 20}()
is an Assignment Operation (Slither line:3214)
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
require(bool,string)(b,str)
my_require(msg.value > 0, value=0)
tArr[_tId]
None
Deposit(target,uint256(uint64((uint256(uint256(t) & k_valueMask) >> 160) & k_value2Mask) << 20))
mask = 32
is an Assignment Operation (Slither line:3214)
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)) | k_executeFlag
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
my_require(false,string(abi.encode(returnData,returnData.length)))
my_require(! isAddressOwner(target),ownerDoesNotExist!!!)
mask
my_require(owners.length < MAX_OWNER_COUNT && r >= 2 && r <= owners.length,addOwner requirement!!!)
getRsv().setABI(l_dHash,32,abi.encodePacked(structures[uint256(uint160(target))]))
None
owners.push(target)
getENS().setOwner(l_dlabelHash,target)
welcomeOneNewOwner(target,MAX_OWNER_COUNT)
nb ++
my_require(value > 0,nb shares = 0!!!)
f = (uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + ((uint64(activeOwners()) / 2) + 1)
is an Assignment Operation (Slither line:3214)
saveExecuted(_tId,f,t)
m = m * 2
is an Assignment Operation (Slither line:3214)
false
None
o --
my_require(address(address(uint160(target))).send(welcomeBudget),Funding new member failed.)
Deposit(target,welcomeBudget)
l_token.transfer_G8l(target,value)
saveExecuted(_tId,f,t)
nb
None
AbstractTokenMaster(AbstractGroupWalletFactory(GWF).getProxyToken(l_dHash)).drainShares(l_dHash,GWF,owners[ownerId],target)
removeOneOwner(target)
f = (uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + ((uint64(activeOwners()) / 2) + 1)
is an Assignment Operation (Slither line:3214)
saveExecuted(_tId,f,t)
AbstractTokenMaster(AbstractGroupWalletFactory(GWF).getProxyToken(l_dHash)).transfer_G8l(target,10000)
None
ownerChange(target,address(0x0))
true
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
None
i ++
false
my_require(! isAddressOwner(target),ownerDoesNotExist!!!)
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
i ++
tArr[_tId] = uint256(uint256(uint256((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)) | k_executeFlag)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
None
my_require(address(address(uint160(target))).send(val),Refunding ex-member failed.)
owners[i] = _newOwner
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
welcomeOneNewOwner(target,ownerNb)
Deposit(target,val)
None
ownerChange(owners[ownerNb],target)
saveExecuted(_tId,f,t)
saveExecuted(_tId,f,t)
count = 0
is an Assignment Operation (Slither line:3214)
None
None
my_require(false,ownerChange illegal owner!!!)
my_require(false,cmd type!!!)
getENS().setSubnodeRecord(l_dHash,l_label,address(this),address(getRsv()),uint64(block.timestamp * 1000) & uint64(0xffffffffffff0000))
saveExecuted(_tId,f,t)
Checking function: storeLegacyProxyToken(bytes32,uint64) returns(address) (Slither line:3125)
Visibility: internal
Checking function: sendSpinoffAssets(uint256,uint64,bytes32[],uint256) returns(bool) (Slither line:3125)
Visibility: internal
Checking function: confirmSpinOffGroup_L51b(bytes32[],bytes,bytes32[],bytes32[]) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
my_require(address(address(uint160(uint256(_mem[7 + (o_scope_3 * 4)]) & k_addressMask))).send(uint256(uint256(t_scope_4) & k_addressMask) - cost),Forwarding failed.)
getRsv().setABI(bytes32(tArr[uint256(uint160(GWF))]),128,abi.encodePacked(_abi))
i ++
Deposit(address(uint160(uint256(_mem[7 + (o_scope_3 * 4)]) & k_addressMask)),uint256(uint256(t_scope_4) & k_addressMask) - cost)
AbstractGroupWalletFactory(GWF).replicate_group_l9Y{value: msg.value * 9 / 10}(_in,data32,_mem)
AbstractENS(AbstractGroupWalletFactory(GWF).ens())
sum = sum - uint256(uint256(uint256(t_scope_4) & k_addressMask) - cost)
is an Assignment Operation (Slither line:3214)
saveExecuted(_tId,f,t)
count ++
i = 0
is an Assignment Operation (Slither line:3214)
0
require(bool,string)(sendSpinoffAssets(_tId,f,_mem,totalGas),sendSpinoffAssets failed)
AbstractGroupWalletFactory(GWF).resolverContract()
flag = flag ^ uint64(2 ** uint64(o_scope_3))
is an Assignment Operation (Slither line:3214)
i ++
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
count
ownerId = uint64(ownerIdFromFlag(uint64(flag)))
is an Assignment Operation (Slither line:3214)
my_require(isAddressOwner(msg.sender), no owner)
true
rArr[i] = bArr[i]
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[_tId] = uint256(uint256(uint256(flags) << 216) & k_flagsMask) + uint256(tArr[_tId] & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
AbstractGroupWalletProxy(gwp).submitFirstTransaction_gm{value: 0}(tRecord,uint256(newHash))
gwp
require(bool,string)(b,str)
my_require(msg.value > 0, value=0)
off --
i ++
tArr[_tId]
my_require(address(address(uint160(target))).send(sum),Payback sender failed.)
string(rArr)
bytes32(uint256(uint256(_in) | 0x2000000000000000000000000000000000000000000000000000000000000000))
Deposit(address(uint160(target)),sum)
mask = 32
is an Assignment Operation (Slither line:3214)
_in
my_require(address(address(uint160(target))).send(address(this).balance),Payback failed.)
my_require(uint64(f & getOwnerMask(msg.sender)) == 0 && uint8((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask) < 128 && (((t & k_typeMask) >> 252) == 8) && isAddressOwner(msg.sender),notConfirmed,notExecuted,nb,owner)
Deposit(address(uint160(target)),address(this).balance)
my_require(owners.length > 3,group too small!)
getOpenSplitTransactionNb(tNb - 1,exec)
o = o * 2
is an Assignment Operation (Slither line:3214)
i ++
None
t = uint256(_mem[7 + (f_s * 4)]) & k_addressMask
is an Assignment Operation (Slither line:3214)
f = uint64(f | getOwnerMask(msg.sender))
is an Assignment Operation (Slither line:3214)
f_s ++
id = 1
is an Assignment Operation (Slither line:3214)
mask
AbstractTokenMaster(AbstractGroupWalletFactory(GWF).getProxyToken(hash)).drainShares(hash,GWF,owners[i],address(uint160(t)))
drainLegacyShares(hash,i,address(uint160(t)))
i_scope_1 ++
ownerChange(owners[i],address(0x0))
i --
nb ++
i ++
sum = sum + uint256(msg.sender.balance) + uint256(msg.value * 9 / 10)
is an Assignment Operation (Slither line:3214)
0
m = m * 2
is an Assignment Operation (Slither line:3214)
false
nbSpinOwners = f_s
is an Assignment Operation (Slither line:3214)
o --
f_s = uint64(uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + ((uint64(activeOwners()) / 2) + 1)
is an Assignment Operation (Slither line:3214)
cost = uint256(uint256(uint256(totalGas - gasleft()() - uint256(23504 * nbm)) * tx.gasprice)) + uint256(msg.value)
is an Assignment Operation (Slither line:3214)
i
saveFlags(_tId,f_s)
cost = uint256(cost / uint256(nbm))
is an Assignment Operation (Slither line:3214)
sum = sum - (cost * uint256(nbm))
is an Assignment Operation (Slither line:3214)
nb
idx = 0
is an Assignment Operation (Slither line:3214)
id = id * 2
is an Assignment Operation (Slither line:3214)
i ++
sum = sum + uint256(msg.sender.balance)
is an Assignment Operation (Slither line:3214)
0
true
i ++
0
tt = tArr[i]
is an Assignment Operation (Slither line:3214)
false
i ++
t_scope_0 = tArr[i_scope_1]
is an Assignment Operation (Slither line:3214)
i ++
tArr[_tId] = uint256(uint256(uint256((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)) | k_executeFlag)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
cmd = (t_scope_0 & k_typeMask) >> 252
is an Assignment Operation (Slither line:3214)
owners[i] = _newOwner
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[i_scope_2] = uint256(uint256((uint256(uint64(uint64(nbSpinOwners) / 2) + 1) << 216) & k_flagsMask) + uint256(t_scope_4 & k_flags3Mask)) | k_executeFlag
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
t_scope_4 = tArr[i_scope_2]
is an Assignment Operation (Slither line:3214)
TestReturn(uint256(uint160(legacyTokenContract)),uint256(uint160(target)),uint256(uint160(owners[nb])),uint256(dhash))
None
AbstractGroupWalletProxy(gwp).submitLegacyTransaction{value: 0}(i_scope_1 + 1,t_scope_0)
AbstractTokenProxy(legacyTokenContract).drainLegacyShares(dhash,GWF,owners[nb],target)
t = tArr[i]
is an Assignment Operation (Slither line:3214)
count = 0
is an Assignment Operation (Slither line:3214)
i_scope_2 ++
bArr[i] = _b[i]
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
f = uint64(uint256((uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask))
is an Assignment Operation (Slither line:3214)
o_scope_3 = uint8((uint256(uint256(t_scope_4) & k_assetMask) >> 208) & k_asset2Mask)
is an Assignment Operation (Slither line:3214)
a = uint8(uint256((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask))
is an Assignment Operation (Slither line:3214)
my_require(false,ownerChange illegal owner!!!)
off = i
is an Assignment Operation (Slither line:3214)
sum = sum + uint256(uint256(t_scope_0) & k_addressMask)
is an Assignment Operation (Slither line:3214)
i
Checking function: drainLegacyShares(bytes32,uint256,address) returns() (Slither line:3125)
Visibility: internal
Checking function: submitFirstTransaction_gm(uint256,uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
i ++
false
mask = 32
is an Assignment Operation (Slither line:3214)
0
my_require(isAddressOwner(msg.sender) || isLegacyToken,not an owner or no legacyProxy!)
false
my_require(tArr[0] == 0,tArr in use error!!!)
tArr[0] = uint256((uint256(uint64(uint64(owners.length >> 1) + 1) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(firstTRecord) & k_flags4Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[0] = uint256((uint256(uint64(uint64(owners.length >> 1) + 1) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(firstTRecord) & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[uint256(uint160(GWF))] = dhash
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
require(bool,string)(b,str)
mask
GroupWalletDeployed(msg.sender,owners.length,uint256(block.timestamp))
true
Checking function: submitLegacyTransaction(uint256,uint256) returns() (Slither line:3125)
Visibility: external
tArr[tNb] = uint256(uint256(uint256(uint256(uint64(uint64(owners.length >> 1) + 1)) << 216) & k_flagsMask) + uint256(uint256(tRecord) & k_flags4Mask)) | k_executeFlag
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
my_require(isLegacyToken,no legacy transaction!)
require(bool,string)(b,str)
my_require(tNb > 0,tNb=0 !)
my_require(tArr[tNb] == 0,tArr overwrite error!!!)
Checking function: submitTransaction_Hom(uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
my_require(tArr[tNb] == 0,tArr overwrite error!!!)
i ++
i ++
None
mask = 32
is an Assignment Operation (Slither line:3214)
false
0
false
my_require(uint256(uint256(tRecord & k_typeMask) >> 252) == cmd,action nb!)
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
my_require(tNb > 0,value=0 !)
checkPreconditions(msg.value,aTRecord,0)
tArr[msg.value] = uint256((uint256(uint64(getTRequired(msg.value - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
mask
require(bool,string)(b,str)
true
my_require(isAddressOwner(msg.sender),ownerExists!!!)
Checking function: submitSplitTransaction(uint256,bytes32,bytes32) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
0
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
my_require(tNb > 0,value=0 !)
require(bool,string)(b,str)
checkPreconditions(msg.value,aTRecord,7)
my_require(isAddressOwner(msg.sender),ownerExists!!!)
my_require(checkSplitPreconditions(msg.value,0) == 0,split 0!)
my_require(tArr[tNb] == 0,tArr overwrite error!!!)
tArr[msg.value] = uint256((uint256(uint64(getTRequired(msg.value - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[uint256(_commitment) & k_addressMask] = uint256(_commitment)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[(uint256(_commitment) & k_addressMask) + 1] = uint256(_dname)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
bArr[i] = _b[i]
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
None
mask = 32
is an Assignment Operation (Slither line:3214)
AbstractGroupWalletFactory(GWF).reserve_replicate(dHashFromLabelBytes32(_dname),_commitment)
i ++
my_require(uint256(uint256(tRecord & k_typeMask) >> 252) == cmd,action nb!)
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
my_require(owners.length > 3,group too small!)
string(bArr)
getOpenSplitTransactionNb(tNb - 1,exec)
mask
i --
nb ++
keccak256(bytes)(abi.encodePacked(AbstractGroupWalletFactory(GWF).base().baseNode(),keccak256(bytes)(bytes(bytesToStr(_name,uint256(_name) & 0xff)))))
0
m = m * 2
is an Assignment Operation (Slither line:3214)
false
o --
nb
idx = 0
is an Assignment Operation (Slither line:3214)
true
i ++
0
false
t = tArr[i]
is an Assignment Operation (Slither line:3214)
f = uint64(uint256((uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask))
is an Assignment Operation (Slither line:3214)
a = uint8(uint256((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask))
is an Assignment Operation (Slither line:3214)
i
Checking function: submitExecuteSplitTransaction(uint256,uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
AbstractENS(AbstractGroupWalletFactory(GWF).ens())
s[0] = 0x30
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
0
s[1] = 0x78
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
AbstractGroupWalletFactory(GWF).resolverContract()
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
.glmr
my_require(tNb > 0,value=0 !)
require(bool,string)(b,str)
.etc
i ++
AbstractGroupWalletFactory(GWF).controllerContract()
my_require(isAddressOwner(msg.sender),ownerExists!!!)
.eth
my_require(tArr[tNb] == 0,tArr overwrite error!!!)
bArr[i] = _b[i]
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
None
mask = 32
is an Assignment Operation (Slither line:3214)
s[2 + (2 * i)] = char(hi)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
i ++
s[2 + (2 * i) + 1] = char(lo)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
bytes1(uint8(b) + 0x30)
my_require(uint256(uint256(tRecord & k_typeMask) >> 252) == cmd,action nb!)
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
string(s)
string(bArr)
my_require(owners.length > 3,group too small!)
bytes1(uint8(b) + 0x57)
getOpenSplitTransactionNb(tNb - 1,exec)
mask
i --
nb ++
keccak256(bytes)(abi.encodePacked(AbstractGroupWalletFactory(GWF).base().baseNode(),keccak256(bytes)(bytes(bytesToStr(_name,uint256(_name) & 0xff)))))
0
m = m * 2
is an Assignment Operation (Slither line:3214)
false
o --
getCtrl().registerWithConfig{value: _rent}(_dname,address(this),uint256(365 * 86400),bytes32(_secret),address(getRsv()),GWF)
getRsv().setName(dHash,string(abi.encodePacked(_dname,tldOfChain())))
nb
idx = 0
is an Assignment Operation (Slither line:3214)
getENS().setOwner(dHash,GWF)
tArr[tNb] = uint256((uint256(uint64(getTRequired(tNb - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
true
i ++
0
false
checkPreconditions(tNb,aTRecord,8)
my_require(uint256(tArr[uint160(aTRecord) & k_addressMask] & k_addressMask) == (uint256(aTRecord) & k_addressMask),string(abi.encodePacked(bytes32ToAsciiString(bytes32(uint256(tArr[uint160(aTRecord) & k_addressMask] & k_addressMask)),32), unknown domain!!!)))
t = tArr[i]
is an Assignment Operation (Slither line:3214)
f = uint64(uint256((uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask))
is an Assignment Operation (Slither line:3214)
a = uint8(uint256((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask))
is an Assignment Operation (Slither line:3214)
my_require(splitTNb > 0,string(abi.encodePacked(bytes32ToAsciiString(bytes32(splitTNb),32), no split)))
tArr[splitTNb] = uint256(uint256(tArr[splitTNb]) | k_executeFlag)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
i
Checking function: getMemberWelcome(address) returns(bytes) (Slither line:3125)
Visibility: external
abi.encode(tArr[uint256(uint160(target) + 2)],tArr[uint256(uint160(target) + 3)])
i ++
false
false
require(bool,string)(b,str)
my_require(isAddressOwner(target),NOT an owner!!!)
true
Checking function: submitTransaction_addUser(uint256,uint256,uint256,uint256,uint256,bytes) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
i ++
AbstractENS(AbstractGroupWalletFactory(GWF).ens())
my_require(getENS().owner(bytes32(tArr[uint256(uint160(GWF))])) == address(this), - GWP contract is NOT domain owner!)
tArr[0] = uint256((uint256(uint64(uint64(owners.length >> 1) + 1) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
false
mask = 32
is an Assignment Operation (Slither line:3214)
my_require(msg.value > 0 || (msg.value == 0 && dhash > 0x0),bad msg.value!!!)
0
tArr[uint256(uint160(GWF))] = dhash
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
false
GroupWalletDeployed(msg.sender,owners.length,uint256(block.timestamp))
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
tArr[msg.value] = uint256(uint256(uint256(uint64(getTRequired(msg.value - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
my_require(isAddressOwner(msg.sender) && (((aTRecord & k_typeMask) >> 252 == 2) || ((aTRecord & k_typeMask) >> 252 == 4)),only owner, bad cmd)
tArr[targetId + 1] = labelHash
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
tArr[targetId + 2] = memK1
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
mask
require(bool,string)(b,str)
tArr[targetId + 3] = memK2
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
true
structures[targetId] = data
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
Checking function: executeTransaction_G1A(uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
my_require((newMaj >= 2) && (newMaj <= MAX_OWNER_COUNT),required 2-31!!!)
f = (uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + uint64(newMaj)
is an Assignment Operation (Slither line:3214)
AbstractENS(AbstractGroupWalletFactory(GWF).ens())
count ++
saveExecuted(_tId,f,t)
getRsv().setAddr(l_dlabelHash,target)
0
None
AbstractGroupWalletFactory(GWF).resolverContract()
i ++
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
count
(succ,returnData) = target.call{value: uint64((uint256(uint256(t) & k_valueMask) >> 160) & k_value2Mask) << 20}()
is an Assignment Operation (Slither line:3214)
require(bool,string)(b,str)
None
Deposit(target,uint256(uint64((uint256(uint256(t) & k_valueMask) >> 160) & k_value2Mask) << 20))
mask = 32
is an Assignment Operation (Slither line:3214)
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)) | k_executeFlag
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
my_require(false,string(abi.encode(returnData,returnData.length)))
my_require(! isAddressOwner(target),ownerDoesNotExist!!!)
mask
my_require(owners.length < MAX_OWNER_COUNT && r >= 2 && r <= owners.length,addOwner requirement!!!)
getRsv().setABI(l_dHash,32,abi.encodePacked(structures[uint256(uint160(target))]))
None
callExecution(_tId,t,f)
owners.push(target)
getENS().setOwner(l_dlabelHash,target)
welcomeOneNewOwner(target,MAX_OWNER_COUNT)
nb ++
my_require(value > 0,nb shares = 0!!!)
f = (uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + ((uint64(activeOwners()) / 2) + 1)
is an Assignment Operation (Slither line:3214)
saveExecuted(_tId,f,t)
m = m * 2
is an Assignment Operation (Slither line:3214)
false
None
o --
my_require(address(address(uint160(target))).send(welcomeBudget),Funding new member failed.)
Deposit(target,welcomeBudget)
l_token.transfer_G8l(target,value)
saveExecuted(_tId,f,t)
nb
None
AbstractTokenMaster(AbstractGroupWalletFactory(GWF).getProxyToken(l_dHash)).drainShares(l_dHash,GWF,owners[ownerId],target)
removeOneOwner(target)
f = (uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + ((uint64(activeOwners()) / 2) + 1)
is an Assignment Operation (Slither line:3214)
saveExecuted(_tId,f,t)
AbstractTokenMaster(AbstractGroupWalletFactory(GWF).getProxyToken(l_dHash)).transfer_G8l(target,10000)
None
ownerChange(target,address(0x0))
true
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
my_require(isAddressOwner(msg.sender),only by owner!)
None
i ++
None
false
my_require(! isAddressOwner(target),ownerDoesNotExist!!!)
tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
i ++
tArr[_tId] = uint256(uint256(uint256((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)) | k_executeFlag)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
None
my_require(address(address(uint160(target))).send(val),Refunding ex-member failed.)
owners[i] = _newOwner
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
welcomeOneNewOwner(target,ownerNb)
Deposit(target,val)
None
ownerChange(owners[ownerNb],target)
saveExecuted(_tId,f,t)
saveExecuted(_tId,f,t)
count = 0
is an Assignment Operation (Slither line:3214)
None
None
my_require(uint64(f & o) > 0,confirmed!!!)
my_require(false,ownerChange illegal owner!!!)
my_require(uint8((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask) < 128,G1a notExecuted!!!)
my_require(false,cmd type!!!)
f = uint64(uint64((uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask))
is an Assignment Operation (Slither line:3214)
getENS().setSubnodeRecord(l_dHash,l_label,address(this),address(getRsv()),uint64(block.timestamp * 1000) & uint64(0xffffffffffff0000))
saveExecuted(_tId,f,t)
Checking function: welcomeOneNewOwner(address,uint256) returns() (Slither line:3125)
Visibility: internal
Checking function: callExecution(uint256,uint256,uint64) returns() (Slither line:3125)
Visibility: internal
Checking function: removeOneOwner(address) returns() (Slither line:3125)
Visibility: internal
Checking function: activeOwners() returns(uint8) (Slither line:3125)
Visibility: private
Checking function: revokeConfirmation_NlP(uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
i ++
my_require(o > 0,no OwnerMask!!!)
false
mask = 32
is an Assignment Operation (Slither line:3214)
0
my_require(uint64(f & o) > 0,confirmed!!!)
false
my_require((uint256(t) & k_executeFlag) == 0,cannot revoke executed!!!)
tArr[_tId] = uint256((uint256(uint64(f | o) ^ uint64(o)) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
my_require(isAddressOwner(msg.sender),not an owner!)
require(bool,string)(b,str)
mask
true
Checking function: getTNumberPublic() returns(uint256) (Slither line:3125)
Visibility: public
count += 1
is an Assignment Operation (Slither line:3214)
count
i ++
count = 0
is an Assignment Operation (Slither line:3214)
Checking function: isConfirmed(uint256) returns(bool) (Slither line:3125)
Visibility: public
(r <= c)
nb ++
r = uint64(owners.length >> 1) + 1
is an Assignment Operation (Slither line:3214)
m = m * 2
is an Assignment Operation (Slither line:3214)
o --
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
r = uint64(getTRequired(_tNb - 1))
is an Assignment Operation (Slither line:3214)
nb
r = uint64(owners.length >> 1) + 1
is an Assignment Operation (Slither line:3214)
Checking function: getRequiredPublic(uint256) returns(uint256) (Slither line:3125)
Visibility: external
uint256(uint64(owners.length >> 1) + 1)
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
getTRequired(_tNb - 1)
Checking function: getIsOwner(address) returns(bool) (Slither line:3125)
Visibility: external
isAddressOwner(_owner)
false
false
i ++
true
Checking function: getTransactionsCount() returns(uint256) (Slither line:3125)
Visibility: external
count += 1
is an Assignment Operation (Slither line:3214)
getTNumberPublic()
count
i ++
count = 0
is an Assignment Operation (Slither line:3214)
Checking function: getTransactions(uint256) returns(address,uint256,uint8,bool,uint64,uint8,bool) (Slither line:3125)
Visibility: external
(r <= c)
count += 1
is an Assignment Operation (Slither line:3214)
(getAsset(_tNb) > 127)
i ++
count = 0
is an Assignment Operation (Slither line:3214)
nb ++
r = uint64(owners.length >> 1) + 1
is an Assignment Operation (Slither line:3214)
uint64(uint256((uint256(uint256(tArr[tNb]) & k_valueMask) >> 160) & k_value2Mask))
uint8(uint256(uint256(uint256(uint256(tArr[tNb]) & k_assetMask) >> 208) & k_asset2Mask))
address(uint160(uint256(uint256(tArr[tNb]) & k_addressMask)))
m = m * 2
is an Assignment Operation (Slither line:3214)
count
o --
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
r = uint64(getTRequired(_tNb - 1))
is an Assignment Operation (Slither line:3214)
nb
uint8(uint256(uint256(uint256(uint256(tArr[tNb]) & k_typeMask) >> 252) & k_type2Mask))
r = uint64(owners.length >> 1) + 1
is an Assignment Operation (Slither line:3214)
(getTarget(_tNb),getTValue(_tNb),getAsset(_tNb),isTExecuted(_tNb),getFlags(_tNb),getType(_tNb),isConfirmed(_tNb))
Checking function: getTransactionRecord(uint256) returns(uint256) (Slither line:3125)
Visibility: external
0
count += 1
is an Assignment Operation (Slither line:3214)
tArr[_tNb]
count
i ++
count = 0
is an Assignment Operation (Slither line:3214)
Checking function: getAllTransactions() returns(uint256[]) (Slither line:3125)
Visibility: public
i ++
new uint256[](0)
i ++
token = address(uint160(uint256(t & k_addressMask)))
is an Assignment Operation (Slither line:3214)
resultArr[i] = uint256(t & k_value3Mask) + uint256(uint256(uint256(AbstractTokenProxy(token).balanceOf(tx.origin)) << 160) & k_valueMask)
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
i = 0
is an Assignment Operation (Slither line:3214)
resultArr[i] = t
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
resultArr
t = tArr[i]
is an Assignment Operation (Slither line:3214)
count += 1
is an Assignment Operation (Slither line:3214)
Checking function: getConfirmationCount(uint256) returns(uint256) (Slither line:3125)
Visibility: external
uint256(nbOfConfirmations(uint64(f >> 5)))
m = m * 2
is an Assignment Operation (Slither line:3214)
nb
o --
nb ++
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
Checking function: getTransactionCount(bool,bool) returns(uint256) (Slither line:3125)
Visibility: external
count += 1
is an Assignment Operation (Slither line:3214)
(getAsset(_tNb) > 127)
count = 0
is an Assignment Operation (Slither line:3214)
i ++
count += 1
is an Assignment Operation (Slither line:3214)
uint8(uint256(uint256(uint256(uint256(tArr[tNb]) & k_assetMask) >> 208) & k_asset2Mask))
count
i ++
0
Checking function: addressConfirmations(uint256,address) returns(bool) (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i ++
ownerConfirmed(_tNb,_owner)
mask = 32
is an Assignment Operation (Slither line:3214)
0
(uint64(f & o) > 0)
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
mask
Checking function: getOwners() returns(address[]) (Slither line:3125)
Visibility: external
owners
Checking function: getConfirmations(uint256) returns(address[]) (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
i = 0
is an Assignment Operation (Slither line:3214)
i ++
mask = 32
is an Assignment Operation (Slither line:3214)
0
(uint64(f & o) > 0)
_confirmations[i] = confirmationsTemp[i]
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
i ++
confirmationsTemp[count ++] = owners[i]
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
i ++
mask
_confirmations = new address[](count)
is an Assignment Operation (Slither line:3214)
Checking function: nbOfConfirmations(uint64) returns(uint64) (Slither line:3125)
Visibility: internal
Checking function: isAddressOwner(address) returns(bool) (Slither line:3125)
Visibility: private
Checking function: ownerChange(address,address) returns() (Slither line:3125)
Visibility: private
Checking function: getOwnerMask(address) returns(uint64) (Slither line:3125)
Visibility: private
Checking function: ownerIdFromFlag(uint64) returns(uint64) (Slither line:3125)
Visibility: private
Checking function: isTExecuted(uint256) returns(bool) (Slither line:3125)
Visibility: private
Checking function: getOpenSplitTransactionNb(uint256,uint8) returns(uint256) (Slither line:3125)
Visibility: private
Checking function: ownerConfirmed(uint256,address) returns(bool) (Slither line:3125)
Visibility: private
Checking function: getTRequired(uint256) returns(uint64) (Slither line:3125)
Visibility: private
Checking function: newProxyGroupWallet_j5O(address[]) returns() (Slither line:3125)
Visibility: external
my_require(_owners[i] != address(0x0),Bad owner list!)
require(bool,string)(b,str)
owners.push(_owners[i])
GWF = msg.sender
is an Assignment Operation (Slither line:3214)
i ++
Checking function: saveAsset(bytes32,uint256,string,string) returns() (Slither line:3125)
Visibility: external
ColorTableSaved(dhash)
i ++
AbstractENS(AbstractGroupWalletFactory(GWF).ens())
false
false
EtherScriptSaved(dhash,key)
AbstractGroupWalletFactory(GWF).resolverContract()
my_require(isAddressOwner(msg.sender) && dhash != 0x0 && getENS().recordExists(dhash) && getENS().owner(dhash) == address(this),- owner,domain hash,domain exist,only owner)
getRsv().setText(dhash,key,data)
my_require(pHash > 0 && getENS().owner(bytes32(pHash)) == address(this) && bytes32(pHash) == dhash, - pHash,GWP NOT owner/hash unexpected)
require(bool,string)(b,str)
true
Checking function: forwardEther(address) returns() (Slither line:3125)
Visibility: external
my_require(msg.value > 0 && receiver.send(msg.value),Forwarding failed.)
Deposit(receiver,msg.value)
require(bool,string)(b,str)
Checking function: depositEther(uint256,uint256) returns() (Slither line:3125)
Visibility: external
mask = mask * 2
is an Assignment Operation (Slither line:3214)
Deposit(address(address(this)),uint256(msg.value))
i ++
mask = 32
is an Assignment Operation (Slither line:3214)
0
uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))
my_require(tNb > 0 && tArr[tNb] == 0,depositEther failed.)
uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))
my_require(msg.value > 0 && uint160(commit) != 0x0 && uint256(uint256(aTRecord & k_typeMask) >> 252) == 10,value=0,address,cmd)
require(bool,string)(b,str)
mask
tArr[tNb] = uint256(uint256(uint256(uint64(uint64(getTRequired(tNb - 1)) | o)) << 216) & k_flagsMask) + uint256(uint256(uint256(aTRecord) & k_address2Mask) + uint256(msg.value))
is an Assignment Operation (Slither line:3214)
Left side is an IndexAccess (Slither line:3243)
Checking function: fallback() returns() (Slither line:3125)
Checking function: receive() returns() (Slither line:3125)
Checking function: version() returns(uint256) (Slither line:3125)
Visibility: external
20010010
Checking function: constructor(address[]) returns() (Slither line:3125)
Checking function: slitherConstructorConstantVariables() returns() (Slither line:3125)
Visibility: internal

End GroupWalletMaster.find_setter_in_contract (Slither line:3343)


Begin GroupWalletMaster.getter_return_is_non_constant (Slither line:2881)

Found getter function but not setter
Checking if getter calls any other function
