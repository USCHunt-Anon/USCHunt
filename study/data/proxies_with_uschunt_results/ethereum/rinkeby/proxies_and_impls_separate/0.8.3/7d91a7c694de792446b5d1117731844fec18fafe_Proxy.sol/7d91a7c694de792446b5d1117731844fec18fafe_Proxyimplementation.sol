/* ENTER COPYRIGHT INFORMATION HERE */

// : GPL-3.0-only
pragma solidity ^0.8.3;

//import'../modules/common/IModule.sol';
//import'./IWallet.sol';

/**
 * @title BaseWallet
 * @notice Simple modular wallet that authorises modules to call its invoke() method.
 * @author Julien Niset - <julien@argent.xyz>
 */
contract BaseWallet is IWallet {
  // The owner
  address public override owner;
  // The authorised modules
  mapping(address => bool) public override authorised;
  // module executing static calls
  address public staticCallExecutor;
  // The number of modules
  uint256 public override modules;

  event AuthorisedModule(address indexed module, bool value);
  event Invoked(
    address indexed module,
    address indexed target,
    uint256 indexed value,
    bytes data
  );
  event Received(uint256 indexed value, address indexed sender, bytes data);
  event OwnerChanged(address wallet, address newOwner);

  /**
   * @notice Throws if the sender is not an authorised module.
   */
  modifier moduleOnly() {
    require(authorised[msg.sender], 'BW: sender not authorized');
    _;
  }

  /**
   * @notice Inits the wallet by setting the owner and authorising a list of modules.
   * @param _owner The owner.
   * @param _modules The modules to authorise.
   */
  function init(address _owner, address[] calldata _modules) external {
    require(
      owner == address(0) && modules == 0,
      'BW: wallet already initialised'
    );
    require(_modules.length > 0, 'BW: empty modules');
    owner = _owner;
    modules = _modules.length;
    for (uint256 i = 0; i < _modules.length; i++) {
      require(authorised[_modules[i]] == false, 'BW: module is already added');
      authorised[_modules[i]] = true;
      IModule(_modules[i]).init(address(this));
      emit AuthorisedModule(_modules[i], true);
    }
    if (address(this).balance > 0) {
      emit Received(address(this).balance, address(0), '');
    }
  }

  /**
   * @inheritdoc IWallet
   */
  function authoriseModule(address _module, bool _value)
    external
    override
    moduleOnly
  {
    if (authorised[_module] != _value) {
      emit AuthorisedModule(_module, _value);
      if (_value == true) {
        modules += 1;
        authorised[_module] = true;
        IModule(_module).init(address(this));
      } else {
        modules -= 1;
        require(modules > 0, 'BW: cannot remove last module');
        delete authorised[_module];
      }
    }
  }

  /**
   * @inheritdoc IWallet
   */
  function enabled(bytes4 _sig) public view override returns (address) {
    address executor = staticCallExecutor;
    if (executor != address(0) && IModule(executor).supportsStaticCall(_sig)) {
      return executor;
    }
    return address(0);
  }

  /**
   * @inheritdoc IWallet
   */
  function enableStaticCall(
    address _module,
    bytes4 /* _method */
  ) external override moduleOnly {
    if (staticCallExecutor != _module) {
      require(authorised[_module], 'BW: unauthorized executor');
      staticCallExecutor = _module;
    }
  }

  /**
   * @inheritdoc IWallet
   */
  function setOwner(address _newOwner) external override moduleOnly {
    require(_newOwner != address(0), 'BW: address cannot be null');
    owner = _newOwner;
    emit OwnerChanged(address(this), _newOwner);
  }

  /**
   * @notice Performs a generic transaction.
   * @param _target The address for the transaction.
   * @param _value The value of the transaction.
   * @param _data The data of the transaction.
   */
  function invoke(
    address _target,
    uint256 _value,
    bytes calldata _data
  ) external moduleOnly returns (bytes memory _result) {
    bool success;
    (success, _result) = _target.call{value: _value}(_data);
    if (!success) {
      // solhint-disable-next-line no-inline-assembly
      assembly {
        returndatacopy(0, 0, returndatasize())
        revert(0, returndatasize())
      }
    }
    emit Invoked(msg.sender, _target, _value, _data);
  }

  /**
   * @notice This method delegates the static call to a target contract if the data corresponds
   * to an enabled module, or logs the call otherwise.
   */
  fallback() external payable {
    address module = enabled(msg.sig);
    if (module == address(0)) {
      emit Received(msg.value, msg.sender, msg.data);
    } else {
      require(authorised[module], 'BW: unauthorised module');

      // solhint-disable-next-line no-inline-assembly
      assembly {
        calldatacopy(0, 0, calldatasize())
        let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
        case 0 {
          revert(0, returndatasize())
        }
        default {
          return(0, returndatasize())
        }
      }
    }
  }

  receive() external payable {}
}


/* ENTER COPYRIGHT INFORMATION HERE */

// : GPL-3.0-only
pragma solidity >=0.5.4 <0.9.0;

/**
 * @title IWallet
 * @notice Interface for the BaseWallet
 */
interface IWallet {
  /**
   * @notice Returns the wallet owner.
   * @return The wallet owner address.
   */
  function owner() external view returns (address);

  /**
   * @notice Returns the number of authorised modules.
   * @return The number of authorised modules.
   */
  function modules() external view returns (uint256);

  /**
   * @notice Sets a new owner for the wallet.
   * @param _newOwner The new owner.
   */
  function setOwner(address _newOwner) external;

  /**
   * @notice Checks if a module is authorised on the wallet.
   * @param _module The module address to check.
   * @return `true` if the module is authorised, otherwise `false`.
   */
  function authorised(address _module) external view returns (bool);

  /**
   * @notice Returns the module responsible for a static call redirection.
   * @param _sig The signature of the static call.
   * @return the module doing the redirection
   */
  function enabled(bytes4 _sig) external view returns (address);

  /**
   * @notice Enables/Disables a module.
   * @param _module The target module.
   * @param _value Set to `true` to authorise the module.
   */
  function authoriseModule(address _module, bool _value) external;

  /**
   * @notice Enables a static method by specifying the target module to which the call must be delegated.
   * @param _module The target module.
   * @param _method The static method signature.
   */
  function enableStaticCall(address _module, bytes4 _method) external;
}


/* ENTER COPYRIGHT INFORMATION HERE */

// : GPL-3.0-only
pragma solidity ^0.8.3;

/**
 * @title IModule
 * @notice Interface for a Module.
 * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>
 */
interface IModule {
  /**
   * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)
   * @param _wallet The target wallet.
   * @param _module The modules to authorise.
   */
  function addModule(address _wallet, address _module) external;

  /**
   * @notice Inits a Module for a wallet by e.g. setting some wallet specific parameters in storage.
   * @param _wallet The wallet.
   */
  function init(address _wallet) external;

  /**
   * @notice Returns whether the module implements a callback for a given static call method.
   * @param _methodId The method id.
   */
  function supportsStaticCall(bytes4 _methodId)
    external
    view
    returns (bool _isSupported);
}


